{
  "docfx/api/index.html": {
    "href": "docfx/api/index.html",
    "title": "API-Referenz | TinyPl0 Dokumentation",
    "summary": "API-Referenz Die API-Referenz wird aus XML-Kommentaren generiert. Fuer Schulungszwecke sind auch interne und private Member enthalten. Die Zugriffsebene wird in der DocFX-Ansicht entsprechend gekennzeichnet."
  },
  "docfx/appendix/abstand.html": {
    "href": "docfx/appendix/abstand.html",
    "title": "Anhang: Abstand zweier Zahlen | TinyPl0 Dokumentation",
    "summary": "Anhang: Abstand zweier Zahlen Berechnet |a-b|. Programm var a, b, d; begin ? a; ? b; d := a - b; if d < 0 then d := -d; ! d end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Betrag der Differenz. Nutzt Bedingung fuer negatives Ergebnis. Beispiel Eingabe: 5 12 Ausgabe: 7 Testfaelle 10 3 -> 7 -2 4 -> 6 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/altersberechnung.html": {
    "href": "docfx/appendix/altersberechnung.html",
    "title": "Anhang: Altersberechnung | TinyPl0 Dokumentation",
    "summary": "Anhang: Altersberechnung Berechnet Alter aus Geburtsjahr und aktuellem Jahr. Programm var geb, jahr, alter; begin ? geb; ? jahr; alter := jahr - geb; if alter < 0 then alter := 0; ! alter end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Alter = aktuelles Jahr - Geburtsjahr. Negative Werte werden auf 0 gesetzt. Beispiel Eingabe: 2000 2025 Ausgabe: 25 Testfaelle 2025 2025 -> 0 2010 2025 -> 15 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/arithmetische-folge.html": {
    "href": "docfx/appendix/arithmetische-folge.html",
    "title": "Anhang: Arithmetische Folge | TinyPl0 Dokumentation",
    "summary": "Anhang: Arithmetische Folge Gibt eine arithmetische Folge aus. Programm var a, d, n, i, x; begin ? a; ? d; ? n; i := 0; x := a; while i < n do begin ! x; x := x + d; i := i + 1 end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Startwert a und Schritt d. Gibt n Werte aus. Beispiel Eingabe: 2 3 4 Ausgabe: 2 5 8 11 Testfaelle 1 1 3 -> 1 2 3 5 2 2 -> 5 7 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/betrag.html": {
    "href": "docfx/appendix/betrag.html",
    "title": "Anhang: Betrag | TinyPl0 Dokumentation",
    "summary": "Anhang: Betrag Berechnet |x|. Programm var x; begin ? x; if x < 0 then x := -x; ! x end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Bedingung prueft negatives Vorzeichen. Ergebnis ist immer >= 0. Beispiel Eingabe: -9 Ausgabe: 9 Testfaelle 0 -> 0 -1 -> 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/bmi.html": {
    "href": "docfx/appendix/bmi.html",
    "title": "Anhang: BMI | TinyPl0 Dokumentation",
    "summary": "Anhang: BMI BMI in Festkomma (gewicht/(groesse^2)). Programm const scale = 100; var w, h, bmi; begin ? w; ? h; bmi := (w * scale) / ((h * h) / scale); ! bmi end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Festkomma mit scale=100. Groesse in cm, Gewicht in kg. Beispiel Eingabe: 80 180 Ausgabe: 24 Testfaelle 60 170 -> 20 90 180 -> 27 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/countdown.html": {
    "href": "docfx/appendix/countdown.html",
    "title": "Anhang: Countdown | TinyPl0 Dokumentation",
    "summary": "Anhang: Countdown Zaehlt von n nach 0. Programm var n; begin ? n; while n >= 0 do begin ! n; n := n - 1 end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Zaehlt von n bis 0 inklusive. N sollte nicht negativ sein. Beispiel Eingabe: 3 Ausgabe: 3 2 1 0 Testfaelle 0 -> 0 2 -> 2 1 0 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/division-durch-subtraktion.html": {
    "href": "docfx/appendix/division-durch-subtraktion.html",
    "title": "Anhang: Division durch Subtraktion | TinyPl0 Dokumentation",
    "summary": "Anhang: Division durch Subtraktion Teilt a/b durch wiederholtes Subtrahieren. Programm var a, b, q; begin ? a; ? b; q := 0; while a >= b do begin a := a - b; q := q + 1 end; ! q end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Wiederholtes Subtrahieren bis a < b. Ergebnis ist Quotient ohne Rest. Beispiel Eingabe: 17 5 Ausgabe: 3 Testfaelle 9 3 -> 3 8 3 -> 2 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/division-mit-rest.html": {
    "href": "docfx/appendix/division-mit-rest.html",
    "title": "Anhang: Ganzzahl-Division mit Rest | TinyPl0 Dokumentation",
    "summary": "Anhang: Ganzzahl-Division mit Rest Berechnet Quotient und Rest. Programm var a, b, q, r; begin ? a; ? b; q := a / b; r := a - q * b; ! q; ! r end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Rest wird als a - q*b berechnet. b darf nicht 0 sein. Beispiel Eingabe: 17 5 Ausgabe: 3 2 Testfaelle 20 4 -> 5 0 9 2 -> 4 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/dreieck-umfang.html": {
    "href": "docfx/appendix/dreieck-umfang.html",
    "title": "Anhang: Dreiecksumfang | TinyPl0 Dokumentation",
    "summary": "Anhang: Dreiecksumfang Berechnet Umfang eines Dreiecks. Programm var a, b, c, u; begin ? a; ? b; ? c; u := a + b + c; ! u end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Summe aller drei Seiten. Keine Plausibilitaetspruefung. Beispiel Eingabe: 3 4 5 Ausgabe: 12 Testfaelle 1 1 1 -> 3 5 7 9 -> 21 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/dreisatz.html": {
    "href": "docfx/appendix/dreisatz.html",
    "title": "Anhang: Dreisatz | TinyPl0 Dokumentation",
    "summary": "Anhang: Dreisatz Berechnet x aus a:b = c:x. Programm var a, b, c, x; begin ? a; ? b; ? c; x := (b * c) / a; ! x end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Direkte Proportion a:b = c:x. a darf nicht 0 sein. Beispiel Eingabe: 2 10 6 Ausgabe: 30 Testfaelle 4 20 5 -> 25 1 3 2 -> 6 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/dummy-workload.html": {
    "href": "docfx/appendix/dummy-workload.html",
    "title": "Anhang: Schleifenzaehler | TinyPl0 Dokumentation",
    "summary": "Anhang: Schleifenzaehler Einfacher Zaehler fuer Laufzeit. Programm var i, n; begin ? n; i := 0; while i < n do i := i + 1; ! i end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Dient zur Demonstration von Laufzeit/Schleifen. Ausgabe ist der Endzaehler. Beispiel Eingabe: 5 Ausgabe: 5 Testfaelle 0 -> 0 3 -> 3 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/einheitenumrechnung.html": {
    "href": "docfx/appendix/einheitenumrechnung.html",
    "title": "Anhang: Einheitenumrechnung | TinyPl0 Dokumentation",
    "summary": "Anhang: Einheitenumrechnung cm -> m -> km. Programm var cm, m, km; begin ? cm; m := cm / 100; km := m / 1000; ! m; ! km end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details cm -> m -> km, rein ganzzahlig. Rundungen durch Division. Beispiel Eingabe: 12345 Ausgabe: 123 0 Testfaelle 100 -> 1 0 100000 -> 1000 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/fakultaet.html": {
    "href": "docfx/appendix/fakultaet.html",
    "title": "Anhang: Fakultaet | TinyPl0 Dokumentation",
    "summary": "Anhang: Fakultaet Berechnet n! iterativ. Programm var n, i, f; begin ? n; f := 1; i := 2; while i <= n do begin f := f * i; i := i + 1 end; ! f end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Laufvariable i startet bei 2, Ergebnis in f. Fuer n=0 bleibt f=1. Beispiel Eingabe: 5 Ausgabe: 120 Testfaelle 0 -> 1 6 -> 720 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/fibonacci.html": {
    "href": "docfx/appendix/fibonacci.html",
    "title": "Anhang: Fibonacci | TinyPl0 Dokumentation",
    "summary": "Anhang: Fibonacci Dieses Beispiel berechnet die Fibonacci-Folge. Programm var a, b, i, temp; begin a := 0; b := 1; i := 0; while i < 10 do begin ! a; temp := a + b; a := b; b := temp; i := i + 1 end end. Erklaerung a und b halten die aktuellen Werte. temp speichert die Zwischensumme. Die Schleife gibt die ersten 10 Werte aus. Details Iterative Berechnung mit zwei Arbeitsvariablen. Gibt die ersten 10 Werte aus. Beispiel Eingabe: (no input) Ausgabe: 0 1 1 2 3 5 8 13 21 34 Testfaelle (no input) -> 0 1 1 2 3 5 8 13 21 34 (no input) -> 0 1 1 2 3 5 8 13 21 34 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/geometrische-folge.html": {
    "href": "docfx/appendix/geometrische-folge.html",
    "title": "Anhang: Geometrische Folge | TinyPl0 Dokumentation",
    "summary": "Anhang: Geometrische Folge Gibt eine geometrische Folge aus. Programm var a, q, n, i, x; begin ? a; ? q; ? n; i := 0; x := a; while i < n do begin ! x; x := x * q; i := i + 1 end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Startwert a und Faktor q. Gibt n Werte aus. Beispiel Eingabe: 2 3 4 Ausgabe: 2 6 18 54 Testfaelle 1 2 3 -> 1 2 4 3 3 2 -> 3 9 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/geschwindigkeit.html": {
    "href": "docfx/appendix/geschwindigkeit.html",
    "title": "Anhang: Geschwindigkeit | TinyPl0 Dokumentation",
    "summary": "Anhang: Geschwindigkeit Berechnet Strecke s = v * t. Programm var v, t, s; begin ? v; ? t; s := v * t; ! s end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Strecke = Geschwindigkeit * Zeit. Einheit konsistent halten. Beispiel Eingabe: 50 3 Ausgabe: 150 Testfaelle 0 10 -> 0 80 2 -> 160 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/ggt.html": {
    "href": "docfx/appendix/ggt.html",
    "title": "Anhang: GGT | TinyPl0 Dokumentation",
    "summary": "Anhang: GGT Dieses Beispiel berechnet den groessten gemeinsamen Teiler (GGT) zweier Zahlen. Programm var x, y, t; begin ? x; ? y; while y # 0 do begin t := x; x := y; y := t - (t / y) * y end; ! x end. Erklaerung Die Schleife implementiert den Euklidischen Algorithmus. Ergebnis ist der Wert von x. Details Euklidischer Algorithmus per wiederholter Subtraktion/Division. Ergebnis ist der GGT. Beispiel Eingabe: 54 24 Ausgabe: 6 Testfaelle 8 12 -> 4 7 3 -> 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/glossar.html": {
    "href": "docfx/appendix/glossar.html",
    "title": "Anhang: Glossar | TinyPl0 Dokumentation",
    "summary": "Anhang: Glossar Begriffe aus PL/0, P-Code und der VM. Address Die Speicherposition eines Wertes in der VM. Siehe auch: VM-Instruction-Set. Argument Das dritte Feld einer P-Code-Instruktion (OPCODE LEVEL ARG). Siehe auch: P-Code-Handbuch. Basiszeiger (B) Zeigt auf den aktuellen Stack-Frame. Siehe auch: P-Code-Handbuch. Code-Area Der Speicherbereich mit den P-Code-Instruktionen. Siehe auch: P-Code-Handbuch. Compiler Uebersetzt PL/0 in P-Code. Siehe auch: Architektur. Dialekt Variante der Sprache, z. B. classic oder extended. Siehe auch: PL0-Handbuch. EndOfFile Token, das das Dateiende markiert. Siehe auch: API-Referenz. Instruktionszeiger (P) Program Counter, zeigt auf die naechste Instruktion. Siehe auch: P-Code-Handbuch. Lexer Zerlegt Quelltext in Token. Siehe auch: PL0-Handbuch. Level Lexikalische Verschachtelungsebene fuer Variablenzugriff. Siehe auch: P-Code-Handbuch. OPR Opcode fuer arithmetische/vergleichende Operationen. Siehe auch: OPR Referenz. Parser Analysiert Token und erzeugt P-Code. Siehe auch: PL0-Handbuch. P-Code Zwischencode, den die VM ausfuehrt. Siehe auch: P-Code-Handbuch. Stack LIFO-Speicher fuer Werte und lokale Variablen. Siehe auch: P-Code-Handbuch. Stack-Top (T) Zeigt auf das aktuelle Stackende. Siehe auch: P-Code-Handbuch. Symboltabelle Speichert Deklarationen von Konstanten/Variablen/Prozeduren. Siehe auch: PL0-Handbuch. Token Kleinstes syntaktisches Element (z. B. Ident, Number). Siehe auch: PL0-Handbuch. VM Virtuelle Maschine zur Ausfuehrung von P-Code. Siehe auch: VM-Instruction-Set."
  },
  "docfx/appendix/how-to-run.html": {
    "href": "docfx/appendix/how-to-run.html",
    "title": "Anhang: Beispiele ausfuehren | TinyPl0 Dokumentation",
    "summary": "Anhang: Beispiele ausfuehren Die Beispiele liegen als PL/0-Quelltext in der Dokumentation. Zum Ausfuehren kopiere den Code in eine Datei und nutze die CLI. Schritte Datei anlegen, z. B. example.pl0. Programm einfuegen und mit . abschliessen. Ausfuehren: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp Mit --list-code kannst du die generierte P-Code-Liste ausgeben."
  },
  "docfx/appendix/index.html": {
    "href": "docfx/appendix/index.html",
    "title": "Anhang: Beispielprogramme | TinyPl0 Dokumentation",
    "summary": "Anhang: Beispielprogramme Die folgenden Programme sind nach Themen gruppiert. Zahlentheorie und Zahlenfolgen Primzahltest Primzahlen bis N Fakultaet Potenz Fibonacci KGT GGT Summe 1 bis N Summe gerade/ungerade Arithmetische Folge Geometrische Folge Quadratzahlen Kubikzahlen Grundrechenarten und Operatoren Ganzzahl-Division mit Rest Multiplikation durch Addition Division durch Subtraktion Modulo durch Subtraktion Summenquadrat vs. Quadratsumme Vergleich und Logik Zahlenvergleich Paritaetstest Betrag Abstand zweier Zahlen Swap Ziffern und Darstellungen Ziffernsumme Ziffernanzahl Palindromtest Umkehrung einer Zahl Geometrie und Physik Rechteck Umfang und Flaeche Quadrat Umfang und Flaeche Kreis Umfang und Flaeche Dreiecksumfang Pythagoras Geschwindigkeit Mathe-Funktionen (Festkomma) Mathematische Funktionen Statistik und Auswertung Mittelwert Minimum und Maximum Einfache Statistik Alltag und Wirtschaft Dreisatz Prozentrechnung Zins (einfach) Zinseszins Rabattberechnung Versandkostenstaffel Waehrungsumrechnung Temperaturumrechnung Einheitenumrechnung Wechselgeld Notenbewertung BMI Zeit und Kalender Zeitumrechnung Uhrzeitdifferenz Tage zu Wochen Altersberechnung Gleichungen und Interpolation Lineare Gleichung Quadratische Gleichung Lineare Interpolation Sonstiges Countdown Schleifenzaehler Schwierigkeit und Zeit Legende: E = Einfach, M = Mittel, A = Anspruchsvoll. Programm Stufe Zeit Summe 1 bis N E 10-15 min Zahlenvergleich E 10-15 min Paritaetstest E 10-15 min Betrag E 5-10 min Abstand zweier Zahlen E 5-10 min Countdown E 10-15 min Arithmetische Folge E 10-15 min Geometrische Folge M 15-20 min Fibonacci M 20-25 min GGT M 20-25 min KGT M 20-25 min Primzahltest M 20-25 min Primzahlen bis N A 25-35 min Prozentrechnung E 10-15 min Zins (einfach) E 10-15 min Zinseszins M 15-20 min Rechteck Umfang und Flaeche E 10-15 min Kreis Umfang und Flaeche M 15-20 min Lineare Gleichung M 15-20 min Quadratische Gleichung A 25-35 min Ziffernsumme M 15-20 min Palindromtest A 25-35 min"
  },
  "docfx/appendix/kgt.html": {
    "href": "docfx/appendix/kgt.html",
    "title": "Anhang: KGT | TinyPl0 Dokumentation",
    "summary": "Anhang: KGT Dieses Beispiel berechnet das kleinste gemeinsame Vielfache (KGT) zweier Zahlen. Programm var a, b, x, y; procedure gcd; var t; begin while y # 0 do begin t := x; x := y; y := t - (t / y) * y end end; begin ? a; ? b; x := a; y := b; call gcd; ! (a / x) * b end. Erklaerung Der groesste gemeinsame Teiler (GGT) wird mit dem Euklidischen Algorithmus ermittelt. Aus GGT wird das KGT berechnet: KGT = (a / GGT) * b. Details KGT aus GGT abgeleitet: (a/GGT)*b. Nutzt Euklidischen Algorithmus. Beispiel Eingabe: 12 18 Ausgabe: 36 Testfaelle 6 8 -> 24 7 3 -> 21 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/kreis.html": {
    "href": "docfx/appendix/kreis.html",
    "title": "Anhang: Kreis Umfang und Flaeche | TinyPl0 Dokumentation",
    "summary": "Anhang: Kreis Umfang und Flaeche Berechnet Umfang und Flaeche mit Festkomma. Programm const pi = 3141, scale = 1000; var r, u, f; begin ? r; u := (2 * pi * r) / scale; f := (pi * r * r) / scale; ! u; ! f end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details pi als Festkomma (3141/1000). Ergebnisse sind Naeherungen. Beispiel Eingabe: 10 Ausgabe: 62 314 Testfaelle 1 -> 6 3 2 -> 12 12 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/kubikzahlen.html": {
    "href": "docfx/appendix/kubikzahlen.html",
    "title": "Anhang: Kubikzahlen | TinyPl0 Dokumentation",
    "summary": "Anhang: Kubikzahlen Gibt n^3 fuer 1..N aus. Programm var n, i; begin ? n; i := 1; while i <= n do begin ! (i * i * i); i := i + 1 end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Ausgabe von i^3 fuer 1..N. Eignet sich fuer Tabellen. Beispiel Eingabe: 3 Ausgabe: 1 8 27 Testfaelle 1 -> 1 2 -> 1 8 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/lineare-gleichung.html": {
    "href": "docfx/appendix/lineare-gleichung.html",
    "title": "Anhang: Lineare Gleichung | TinyPl0 Dokumentation",
    "summary": "Anhang: Lineare Gleichung Loest ax + b = 0 (ganzzahlig). Programm var a, b, x; begin ? a; ? b; if a = 0 then ! 0 else begin x := -b / a; ! x end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Bei a=0 wird 0 ausgegeben (keine/inf. Loesungen). x wird ganzzahlig berechnet. Beispiel Eingabe: 2 4 Ausgabe: -2 Testfaelle 0 5 -> 0 2 -6 -> 3 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/lineare-interpolation.html": {
    "href": "docfx/appendix/lineare-interpolation.html",
    "title": "Anhang: Lineare Interpolation | TinyPl0 Dokumentation",
    "summary": "Anhang: Lineare Interpolation Berechnet y = y0 + (x-x0)*(y1-y0)/(x1-x0). Programm var x0, y0, x1, y1, x, y; begin ? x0; ? y0; ? x1; ? y1; ? x; y := y0 + (x - x0) * (y1 - y0) / (x1 - x0); ! y end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Lineare Interpolation zwischen (x0,y0) und (x1,y1). x1 darf nicht gleich x0 sein. Beispiel Eingabe: 0 0 10 100 5 Ausgabe: 50 Testfaelle 0 0 10 100 0 -> 0 0 0 10 100 10 -> 100 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/math-functions.html": {
    "href": "docfx/appendix/math-functions.html",
    "title": "Anhang: Mathematische Funktionen | TinyPl0 Dokumentation",
    "summary": "Anhang: Mathematische Funktionen Hinweis: PL/0 arbeitet nur mit Integern. Die folgenden Beispiele nutzen einfache Festkomma-Naeherungen und sind didaktisch gedacht. sin (naehereungsweise) const scale = 1000, six = 6; var x, x2, x3, sinx; begin ? x; /* x in Milliradian */ x2 := (x * x) / scale; x3 := (x2 * x) / scale; sinx := x - (x3 / six); ! sinx end. cos (naehereungsweise) const scale = 1000, two = 2; var x, x2, cosx; begin ? x; x2 := (x * x) / scale; cosx := scale - (x2 / two); ! cosx end. tan (naehereungsweise) var sinx, cosx; begin ? sinx; ? cosx; if cosx = 0 then ! 0 else ! (sinx / cosx) end. Kreisberechnung (Flaeche) const pi = 3141, scale = 1000; var r, area; begin ? r; area := (pi * r * r) / scale; ! area end. Details Festkomma-Naeherungen fuer trigonometrische Funktionen. Ergebnisse sind didaktisch, nicht numerisch exakt. Beispiel Eingabe: 1000 Ausgabe: approx Testfaelle 1000 -> approx 2000 -> approx Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/min-max.html": {
    "href": "docfx/appendix/min-max.html",
    "title": "Anhang: Minimum und Maximum | TinyPl0 Dokumentation",
    "summary": "Anhang: Minimum und Maximum Bestimmt Minimum und Maximum aus N Zahlen. Programm var n, i, x, min, max; begin ? n; ? x; min := x; max := x; i := 1; while i < n do begin ? x; if x < min then min := x; if x > max then max := x; i := i + 1 end; ! min; ! max end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Erstes Element initialisiert min/max. Danach Vergleich in der Schleife. Beispiel Eingabe: 5 3 9 2 8 6 Ausgabe: 2 9 Testfaelle 3 5 5 5 -> 5 5 4 -1 2 0 9 -> -1 9 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/mittelwert.html": {
    "href": "docfx/appendix/mittelwert.html",
    "title": "Anhang: Mittelwert aus N Zahlen | TinyPl0 Dokumentation",
    "summary": "Anhang: Mittelwert aus N Zahlen Liest N Zahlen und berechnet den Mittelwert (Integer). Programm var n, i, sum, x; begin ? n; sum := 0; i := 0; while i < n do begin ? x; sum := sum + x; i := i + 1 end; ! (sum / n) end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Ergebnis ist ganzzahlig gekuerzt. n muss groesser als 0 sein. Beispiel Eingabe: 4 10 20 30 40 Ausgabe: 25 Testfaelle 1 5 -> 5 3 1 2 2 -> 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/modulo-durch-subtraktion.html": {
    "href": "docfx/appendix/modulo-durch-subtraktion.html",
    "title": "Anhang: Modulo durch Subtraktion | TinyPl0 Dokumentation",
    "summary": "Anhang: Modulo durch Subtraktion Berechnet a mod b. Programm var a, b; begin ? a; ? b; while a >= b do a := a - b; ! a end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Wiederholtes Subtrahieren liefert den Rest. Ergebnis entspricht a mod b. Beispiel Eingabe: 17 5 Ausgabe: 2 Testfaelle 8 3 -> 2 7 7 -> 0 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/multiplikation-durch-addition.html": {
    "href": "docfx/appendix/multiplikation-durch-addition.html",
    "title": "Anhang: Multiplikation durch Addition | TinyPl0 Dokumentation",
    "summary": "Anhang: Multiplikation durch Addition Multipliziert a*b durch Wiederholung. Programm var a, b, i, p; begin ? a; ? b; p := 0; i := 0; while i < b do begin p := p + a; i := i + 1 end; ! p end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Wiederholtes Addieren. b bestimmt die Anzahl der Schritte. Beispiel Eingabe: 6 7 Ausgabe: 42 Testfaelle 0 9 -> 0 4 3 -> 12 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/notenbewertung.html": {
    "href": "docfx/appendix/notenbewertung.html",
    "title": "Anhang: Notenbewertung | TinyPl0 Dokumentation",
    "summary": "Anhang: Notenbewertung Punkte -> Note (vereinfacht). Programm var p, n; begin ? p; n := 6; if p >= 90 then n := 1; if p >= 75 then n := 2; if p >= 60 then n := 3; if p >= 45 then n := 4; if p >= 30 then n := 5; ! n end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Einfache Staffelung in Noten 1-6. Grenzen sind didaktisch gewaehlt. Beispiel Eingabe: 78 Ausgabe: 2 Testfaelle 95 -> 1 30 -> 5 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/palindrom.html": {
    "href": "docfx/appendix/palindrom.html",
    "title": "Anhang: Palindromtest | TinyPl0 Dokumentation",
    "summary": "Anhang: Palindromtest Prueft, ob eine Zahl ein Palindrom ist. Programm var n, t, r, d; begin ? n; t := n; r := 0; while t > 0 do begin d := t - (t / 10) * 10; r := r * 10 + d; t := t / 10 end; if r = n then ! 1 else ! 0 end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Dreht Zahl um und vergleicht. Ergebnis: 1 = Palindrom, 0 = nein. Beispiel Eingabe: 1221 Ausgabe: 1 Testfaelle 123 -> 0 11 -> 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/paritaet.html": {
    "href": "docfx/appendix/paritaet.html",
    "title": "Anhang: Paritaetstest | TinyPl0 Dokumentation",
    "summary": "Anhang: Paritaetstest Prueft gerade/ungerade. Programm var x, even; begin ? x; even := 0; if (x / 2) * 2 = x then even := 1; ! even end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Gerade/ungerade ueber Division. Ausgabe: 1 = gerade, 0 = ungerade. Beispiel Eingabe: 8 Ausgabe: 1 Testfaelle 3 -> 0 10 -> 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/potenz.html": {
    "href": "docfx/appendix/potenz.html",
    "title": "Anhang: Potenz | TinyPl0 Dokumentation",
    "summary": "Anhang: Potenz Berechnet a^b durch Wiederholung. Programm var a, b, i, p; begin ? a; ? b; p := 1; i := 0; while i < b do begin p := p * a; i := i + 1 end; ! p end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Exponent wird durch wiederholte Multiplikation aufgebaut. b sollte nicht negativ sein. Beispiel Eingabe: 2 8 Ausgabe: 256 Testfaelle 3 0 -> 1 2 5 -> 32 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/primzahlen-bis-n.html": {
    "href": "docfx/appendix/primzahlen-bis-n.html",
    "title": "Anhang: Primzahlen bis N | TinyPl0 Dokumentation",
    "summary": "Anhang: Primzahlen bis N Gibt Primzahlen bis zu einer oberen Grenze aus. Programm var n, i, j, isPrime; begin ? n; i := 2; while i <= n do begin isPrime := 1; j := 2; while j * j <= i do begin if (i / j) * j = i then isPrime := 0; j := j + 1 end; if isPrime = 1 then ! i; i := i + 1 end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Schleife testet Teilbarkeit nur bis sqrt(n). Ergebnis: 1 = prim, 0 = nicht prim. Beispiel Eingabe: 10 Ausgabe: 2 3 5 7 Testfaelle 5 -> 2 3 5 1 -> (keine Ausgabe) Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/primzahltest.html": {
    "href": "docfx/appendix/primzahltest.html",
    "title": "Anhang: Primzahltest | TinyPl0 Dokumentation",
    "summary": "Anhang: Primzahltest Testet, ob eine Zahl prim ist. Programm var n, i, isPrime; begin ? n; if n < 2 then isPrime := 0; if n >= 2 then begin isPrime := 1; i := 2; while i * i <= n do begin if (n / i) * i = n then isPrime := 0; i := i + 1 end end; ! isPrime end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Schleife testet Teilbarkeit nur bis sqrt(n). Ergebnis: 1 = prim, 0 = nicht prim. Beispiel Eingabe: 7 Ausgabe: 1 Testfaelle 2 -> 1 9 -> 0 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/prozentrechnung.html": {
    "href": "docfx/appendix/prozentrechnung.html",
    "title": "Anhang: Prozentrechnung | TinyPl0 Dokumentation",
    "summary": "Anhang: Prozentrechnung Berechnet Prozentwert p% von grundwert g. Programm var g, p, w; begin ? g; ? p; w := (g * p) / 100; ! w end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Prozentwert = Grundwert * Prozent / 100. Ergebnis ist ganzzahlig. Beispiel Eingabe: 200 15 Ausgabe: 30 Testfaelle 100 50 -> 50 80 25 -> 20 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/pythagoras.html": {
    "href": "docfx/appendix/pythagoras.html",
    "title": "Anhang: Pythagoras | TinyPl0 Dokumentation",
    "summary": "Anhang: Pythagoras Berechnet c^2 = a^2 + b^2. Programm var a, b, c2; begin ? a; ? b; c2 := a * a + b * b; ! c2 end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Berechnet c^2, nicht c. Fuer c waere eine Wurzel noetig. Beispiel Eingabe: 3 4 Ausgabe: 25 Testfaelle 5 12 -> 169 8 15 -> 289 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/quadrat.html": {
    "href": "docfx/appendix/quadrat.html",
    "title": "Anhang: Quadrat Umfang und Flaeche | TinyPl0 Dokumentation",
    "summary": "Anhang: Quadrat Umfang und Flaeche Berechnet Umfang und Flaeche eines Quadrats. Programm var a, u, f; begin ? a; u := 4 * a; f := a * a; ! u; ! f end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Umfang = 4*a. Flaeche = a*a. Beispiel Eingabe: 5 Ausgabe: 20 25 Testfaelle 1 -> 4 1 3 -> 12 9 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/quadratische-gleichung.html": {
    "href": "docfx/appendix/quadratische-gleichung.html",
    "title": "Anhang: Quadratische Gleichung | TinyPl0 Dokumentation",
    "summary": "Anhang: Quadratische Gleichung Diskriminante und ganzzahlige Loesung (vereinfachtes Beispiel). Programm var a, b, c, d, x; begin ? a; ? b; ? c; d := b * b - 4 * a * c; if d < 0 then ! 0 else begin x := (-b + d) / (2 * a); ! x end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Diskriminante d entscheidet ueber Existenz der Loesung. Wurzel wird hier vereinfacht als d behandelt (didaktisch). Beispiel Eingabe: 1 -3 2 Ausgabe: 4 Testfaelle 1 0 -4 -> 4 1 0 4 -> 0 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/quadratzahlen.html": {
    "href": "docfx/appendix/quadratzahlen.html",
    "title": "Anhang: Quadratzahlen | TinyPl0 Dokumentation",
    "summary": "Anhang: Quadratzahlen Gibt n^2 fuer 1..N aus. Programm var n, i; begin ? n; i := 1; while i <= n do begin ! (i * i); i := i + 1 end end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Umfang = 4*a. Flaeche = a*a. Beispiel Eingabe: 4 Ausgabe: 1 4 9 16 Testfaelle 1 -> 1 2 -> 1 4 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/rabatt.html": {
    "href": "docfx/appendix/rabatt.html",
    "title": "Anhang: Rabattberechnung | TinyPl0 Dokumentation",
    "summary": "Anhang: Rabattberechnung Berechnet Preis nach Rabatt in Prozent. Programm var preis, rabatt, neu; begin ? preis; ? rabatt; neu := preis - (preis * rabatt) / 100; ! neu end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Preis minus Prozentanteil. Ergebnis ist ganzzahlig. Beispiel Eingabe: 200 10 Ausgabe: 180 Testfaelle 100 0 -> 100 50 20 -> 40 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/rechteck.html": {
    "href": "docfx/appendix/rechteck.html",
    "title": "Anhang: Rechteck Umfang und Flaeche | TinyPl0 Dokumentation",
    "summary": "Anhang: Rechteck Umfang und Flaeche Berechnet Umfang und Flaeche eines Rechtecks. Programm var a, b, u, f; begin ? a; ? b; u := 2 * (a + b); f := a * b; ! u; ! f end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Umfang = 2*(a+b). Flaeche = a*b. Beispiel Eingabe: 3 4 Ausgabe: 14 12 Testfaelle 2 3 -> 10 6 5 5 -> 20 25 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/recommended-order.html": {
    "href": "docfx/appendix/recommended-order.html",
    "title": "Anhang: Empfohlene Reihenfolge | TinyPl0 Dokumentation",
    "summary": "Anhang: Empfohlene Reihenfolge Diese Reihenfolge ist fuer Auszubildende gedacht. Einstieg Summe 1 bis N Zahlenvergleich Paritaetstest Betrag Abstand zweier Zahlen Schleifen und Folgen Countdown Arithmetische Folge Geometrische Folge Fibonacci Zahlentheorie GGT KGT Primzahltest Primzahlen bis N Anwendungen Prozentrechnung Zins (einfach) Zinseszins Rechteck Umfang und Flaeche Kreis Umfang und Flaeche"
  },
  "docfx/appendix/statistik.html": {
    "href": "docfx/appendix/statistik.html",
    "title": "Anhang: Einfache Statistik | TinyPl0 Dokumentation",
    "summary": "Anhang: Einfache Statistik Summe, Mittel, Min, Max. Programm var n, i, x, sum, min, max; begin ? n; ? x; sum := x; min := x; max := x; i := 1; while i < n do begin ? x; sum := sum + x; if x < min then min := x; if x > max then max := x; i := i + 1 end; ! sum; ! (sum / n); ! min; ! max end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Summe, Mittelwert, Min, Max. Mittelwert ist ganzzahlig. Beispiel Eingabe: 4 2 8 4 6 Ausgabe: 20 5 2 8 Testfaelle 1 5 -> 5 5 5 5 3 1 2 3 -> 6 2 1 3 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/summe-1-bis-n.html": {
    "href": "docfx/appendix/summe-1-bis-n.html",
    "title": "Anhang: Summe 1 bis N | TinyPl0 Dokumentation",
    "summary": "Anhang: Summe 1 bis N Berechnet die Summe 1..N. Programm var n, i, sum; begin ? n; sum := 0; i := 1; while i <= n do begin sum := sum + i; i := i + 1 end; ! sum end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Summation per Schleife; alternative Formel (n*(n+1)/2) moeglich. n sollte nicht negativ sein. Beispiel Eingabe: 10 Ausgabe: 55 Testfaelle 1 -> 1 5 -> 15 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/summe-gerade-ungerade.html": {
    "href": "docfx/appendix/summe-gerade-ungerade.html",
    "title": "Anhang: Summe gerade/ungerade | TinyPl0 Dokumentation",
    "summary": "Anhang: Summe gerade/ungerade Summiert gerade und ungerade Zahlen bis N. Programm var n, i, sEven, sOdd; begin ? n; sEven := 0; sOdd := 0; i := 1; while i <= n do begin if (i / 2) * 2 = i then sEven := sEven + i; if (i / 2) * 2 # i then sOdd := sOdd + i; i := i + 1 end; ! sEven; ! sOdd end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Gerade pruefung per (i/2)*2. Ausgabe: zuerst gerade, dann ungerade Summe. Beispiel Eingabe: 7 Ausgabe: 12 16 Testfaelle 1 -> 0 1 4 -> 6 4 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/summenquadrat-vs-quadratsumme.html": {
    "href": "docfx/appendix/summenquadrat-vs-quadratsumme.html",
    "title": "Anhang: Summenquadrat vs. Quadratsumme | TinyPl0 Dokumentation",
    "summary": "Anhang: Summenquadrat vs. Quadratsumme Vergleicht (sum)^2 und sum(x^2). Programm var n, i, sum, sumsq; begin ? n; sum := 0; sumsq := 0; i := 1; while i <= n do begin sum := sum + i; sumsq := sumsq + i * i; i := i + 1 end; ! (sum * sum); ! sumsq end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Umfang = 4*a. Flaeche = a*a. Beispiel Eingabe: 3 Ausgabe: 36 14 Testfaelle 1 -> 1 1 2 -> 9 5 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/swap.html": {
    "href": "docfx/appendix/swap.html",
    "title": "Anhang: Werte tauschen | TinyPl0 Dokumentation",
    "summary": "Anhang: Werte tauschen Tauscht zwei Werte. Programm var a, b, t; begin ? a; ? b; t := a; a := b; b := t; ! a; ! b end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Tauscht Werte mit Hilfsvariable. Zwei Ausgaben zeigen Ergebnis. Beispiel Eingabe: 7 9 Ausgabe: 9 7 Testfaelle 1 2 -> 2 1 -3 7 -> 7 -3 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/tage-zu-wochen.html": {
    "href": "docfx/appendix/tage-zu-wochen.html",
    "title": "Anhang: Tage zu Wochen | TinyPl0 Dokumentation",
    "summary": "Anhang: Tage zu Wochen Berechnet Wochen und Resttage. Programm var t, w, r; begin ? t; w := t / 7; r := t - w * 7; ! w; ! r end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Wochen = t/7, Resttage = t - Wochen*7. Beispiele mit kleinen Zahlen. Beispiel Eingabe: 17 Ausgabe: 2 3 Testfaelle 7 -> 1 0 0 -> 0 0 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/temperatur-umrechnung.html": {
    "href": "docfx/appendix/temperatur-umrechnung.html",
    "title": "Anhang: Temperaturumrechnung | TinyPl0 Dokumentation",
    "summary": "Anhang: Temperaturumrechnung Celsius in Fahrenheit (Integer). Programm var c, f; begin ? c; f := (c * 9) / 5 + 32; ! f end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Formel F = C*9/5 + 32. Ganzzahlige Rundung durch Division. Beispiel Eingabe: 0 Ausgabe: 32 Testfaelle 100 -> 212 -40 -> -40 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/uhrzeitdifferenz.html": {
    "href": "docfx/appendix/uhrzeitdifferenz.html",
    "title": "Anhang: Uhrzeitdifferenz | TinyPl0 Dokumentation",
    "summary": "Anhang: Uhrzeitdifferenz Differenz zweier Zeiten in Minuten. Programm var h1, m1, h2, m2, t1, t2, d; begin ? h1; ? m1; ? h2; ? m2; t1 := h1 * 60 + m1; t2 := h2 * 60 + m2; d := t2 - t1; if d < 0 then d := -d; ! d end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Berechnet Differenz in Minuten. Ergebnis ist absoluter Wert. Beispiel Eingabe: 9 30 11 0 Ausgabe: 90 Testfaelle 0 0 0 0 -> 0 10 0 11 30 -> 90 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/versandkosten.html": {
    "href": "docfx/appendix/versandkosten.html",
    "title": "Anhang: Versandkostenstaffel | TinyPl0 Dokumentation",
    "summary": "Anhang: Versandkostenstaffel Einfache Staffelung nach Bestellwert. Programm var wert, kosten; begin ? wert; kosten := 0; if wert < 50 then kosten := 5; if wert >= 50 then kosten := 0; ! kosten end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Zwei Stufen: <50 kostet 5, sonst 0. Beispiel fuer einfache Regeln. Beispiel Eingabe: 40 Ausgabe: 5 Testfaelle 50 -> 0 49 -> 5 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/waehrungsumrechnung.html": {
    "href": "docfx/appendix/waehrungsumrechnung.html",
    "title": "Anhang: Waehrungsumrechnung | TinyPl0 Dokumentation",
    "summary": "Anhang: Waehrungsumrechnung Umrechnung mit festem Kurs. Programm const kurs = 110; var eur, jpy; begin ? eur; jpy := eur * kurs; ! jpy end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Fester Kurs als Konstante. Multiplikation ohne Rundung. Beispiel Eingabe: 10 Ausgabe: 1100 Testfaelle 1 -> 110 0 -> 0 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/wechselgeld.html": {
    "href": "docfx/appendix/wechselgeld.html",
    "title": "Anhang: Wechselgeld | TinyPl0 Dokumentation",
    "summary": "Anhang: Wechselgeld Greedy-Wechselgeld fuer feste Muenzen. Programm var betrag, c, n; begin ? betrag; c := betrag / 50; betrag := betrag - c * 50; n := betrag / 20; betrag := betrag - n * 20; ! c; ! n end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Greedy fuer 50 und 20 Einheiten. Rest wird nicht weiter aufgeteilt. Beispiel Eingabe: 130 Ausgabe: 2 1 Testfaelle 70 -> 1 1 40 -> 0 2 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/zahl-umkehrung.html": {
    "href": "docfx/appendix/zahl-umkehrung.html",
    "title": "Anhang: Umkehrung einer Zahl | TinyPl0 Dokumentation",
    "summary": "Anhang: Umkehrung einer Zahl Kehrt die Ziffern einer Zahl um. Programm var n, r, d; begin ? n; r := 0; while n > 0 do begin d := n - (n / 10) * 10; r := r * 10 + d; n := n / 10 end; ! r end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Reversiert Ziffern durch Mod/Division. Ergebnis ist die umgekehrte Zahl. Beispiel Eingabe: 12340 Ausgabe: 4321 Testfaelle 100 -> 1 907 -> 709 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/zahlenvergleich.html": {
    "href": "docfx/appendix/zahlenvergleich.html",
    "title": "Anhang: Zahlenvergleich | TinyPl0 Dokumentation",
    "summary": "Anhang: Zahlenvergleich Vergleicht a und b. Programm var a, b, r; begin ? a; ? b; r := 0; if a < b then r := -1; if a = b then r := 0; if a > b then r := 1; ! r end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Ergebnis: -1 (a<b), 0 (a=b), 1 (a>b). Drei getrennte if-Zweige. Beispiel Eingabe: 5 9 Ausgabe: -1 Testfaelle 5 5 -> 0 9 4 -> 1 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/zeitumrechnung.html": {
    "href": "docfx/appendix/zeitumrechnung.html",
    "title": "Anhang: Zeitumrechnung | TinyPl0 Dokumentation",
    "summary": "Anhang: Zeitumrechnung Sekunden zu hh:mm:ss (ganzzahlig). Programm var s, h, m; begin ? s; h := s / 3600; s := s - h * 3600; m := s / 60; s := s - m * 60; ! h; ! m; ! s end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Sekunden in h/m/s zerlegt. Ergebnisse einzeln ausgegeben. Beispiel Eingabe: 3661 Ausgabe: 1 1 1 Testfaelle 60 -> 0 1 0 59 -> 0 0 59 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/ziffernanzahl.html": {
    "href": "docfx/appendix/ziffernanzahl.html",
    "title": "Anhang: Ziffernanzahl | TinyPl0 Dokumentation",
    "summary": "Anhang: Ziffernanzahl Zaehlt die Ziffern einer Zahl. Programm var n, c; begin ? n; if n = 0 then c := 1; if n # 0 then begin c := 0; while n > 0 do begin n := n / 10; c := c + 1 end end; ! c end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Sonderfall n=0 ergibt 1 Ziffer. Schleife zaehlt durch Division. Beispiel Eingabe: 1005 Ausgabe: 4 Testfaelle 0 -> 1 42 -> 2 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/ziffernsumme.html": {
    "href": "docfx/appendix/ziffernsumme.html",
    "title": "Anhang: Ziffernsumme | TinyPl0 Dokumentation",
    "summary": "Anhang: Ziffernsumme Berechnet die Ziffernsumme einer Zahl. Programm var n, sum, digit; begin ? n; sum := 0; while n > 0 do begin digit := n - (n / 10) * 10; sum := sum + digit; n := n / 10 end; ! sum end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Mod 10 per n - (n/10)*10. Schleife endet bei n=0. Beispiel Eingabe: 472 Ausgabe: 13 Testfaelle 0 -> 0 999 -> 27 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/zins.html": {
    "href": "docfx/appendix/zins.html",
    "title": "Anhang: Zins (einfach) | TinyPl0 Dokumentation",
    "summary": "Anhang: Zins (einfach) Berechnet einfachen Jahreszins. Programm var k, p, z; begin ? k; ? p; z := (k * p) / 100; ! z end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Einfache Verzinsung, kein Zinseszins. p als Prozentwert verwenden. Beispiel Eingabe: 1000 5 Ausgabe: 50 Testfaelle 200 10 -> 20 1500 3 -> 45 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/appendix/zinseszins.html": {
    "href": "docfx/appendix/zinseszins.html",
    "title": "Anhang: Zinseszins | TinyPl0 Dokumentation",
    "summary": "Anhang: Zinseszins Berechnet Endkapital nach n Jahren. Programm var k, p, n, i; begin ? k; ? p; ? n; i := 0; while i < n do begin k := k + (k * p) / 100; i := i + 1 end; ! k end. Erklaerung Eingaben werden mit ? gelesen. Ausgaben erfolgen ueber !. Alle Berechnungen sind ganzzahlig. Details Iterative Verzinsung pro Jahr. p als Prozentwert verwenden. Beispiel Eingabe: 1000 5 2 Ausgabe: 1102 Testfaelle 1000 10 1 -> 1100 1000 10 2 -> 1210 Ausfuehrung Beispiel: dotnet run --project src/Pl0.Cli -- run example.pl0 Tipp: Fuege --list-code hinzu, um den P-Code zu sehen."
  },
  "docfx/curated/architecture.html": {
    "href": "docfx/curated/architecture.html",
    "title": "Architektur (kuratiert) | TinyPl0 Dokumentation",
    "summary": "Architektur (kuratiert) Dieses Kapitel stellt die Architektur von TinyPl0 zusammengefasst dar und bindet die originalen Detailinformationen aus docs/ARCHITECTURE.md ein. Zusammenfassung Drei Projekte: CLI, Core, VM. Compiler-Pipeline: Lexer -> Parser -> Codegenerator. VM fuehrt den P-Code aus und kapselt I/O. Originalinhalt TinyPl0 Architektur Überblick TinyPl0 ist in drei Laufzeitmodule getrennt: flowchart LR A[\"PL/0 Source (.pl0)\"] --> B[\"Pl0.Core\\nLexer + Parser + SymbolTable + CodeGen\"] B --> C[\"P-Code Instructions\"] C --> D[\"Pl0.Vm\\nVirtualMachine\"] D --> E[\"Program Output / Stack State\"] F[\"Pl0.Cli\"] --> B F --> D F --> G[\".pcode Files\"] G --> D Module Pl0.Core: Sprachverarbeitung und Codegenerierung. Pl0.Vm: Stackbasierte P-Code-Ausführung inklusive I/O-Adapter. Pl0.Cli: Bedienoberfläche (compile, run, run-pcode) und Dateifluss. Datenfluss .pl0 wird im Core lexikalisch analysiert. Parser erzeugt aus Tokens P-Code-Instruktionen. CLI kann P-Code als .pcode speichern oder direkt ausführen. VM interpretiert Instruktionen deterministisch auf einem Integer-Stack. Pascal -> C# Mapping (Kompakt) Pascal-Referenz C#-Implementierung getsym/getch Pl0Lexer block/statement/condition/expression Pl0Parser enter/position/table SymbolTable + SymbolEntry gen Pl0Parser.Emit interpret VirtualMachine.Run base(l) VirtualMachine.ResolveBase PrintUsage CliHelpPrinter Dialekte Classic: ohne ?/!, nahe am Pascal-Vorbild. Extended: mit ? ident und ! expression."
  },
  "docfx/curated/index.html": {
    "href": "docfx/curated/index.html",
    "title": "Kuratierte Inhalte aus docs/ | TinyPl0 Dokumentation",
    "summary": "Kuratierte Inhalte aus docs/ Die folgenden Kapitel integrieren die bestehenden Inhalte aus dem Ordner docs/ und ordnen sie in die Gesamtdokumentation ein. Architektur Sprachumfang (EBNF) VM-Instruction-Set Traceability-Matrix Qualitaet"
  },
  "docfx/curated/language-ebnf.html": {
    "href": "docfx/curated/language-ebnf.html",
    "title": "PL/0 Syntax (kuratiert) | TinyPl0 Dokumentation",
    "summary": "PL/0 Syntax (kuratiert) Dieses Kapitel enthaelt die konsolidierte EBNF fuer PL/0 und dient als Referenz. Originalinhalt TinyPl0 Sprachumfang und EBNF Dialekte classic: orientiert am historischen PL/0 ohne ? und !. extended: enthält zusätzlich Eingabe ? ident und Ausgabe ! expression. Konsolidierte EBNF program = block \".\" ; block = [ \"const\" ident \"=\" number { \",\" ident \"=\" number } \";\" ] [ \"var\" ident { \",\" ident } \";\" ] { \"procedure\" ident \";\" block \";\" } statement ; statement = [ ident \":=\" expression | \"call\" ident | \"?\" ident | \"!\" expression | \"begin\" statement { \";\" statement } \"end\" | \"if\" condition \"then\" statement | \"while\" condition \"do\" statement ] ; condition = \"odd\" expression | expression relop expression ; relop = \"=\" | \"#\" | \"<\" | \"<=\" | \">\" | \">=\" | \"[\" | \"]\" ; expression = [ \"+\" | \"-\" ] term { ( \"+\" | \"-\" ) term } ; term = factor { ( \"*\" | \"/\" ) factor } ; factor = ident | number | \"(\" expression \")\" ; Hinweise zur Kompatibilität [ und ] werden als historische Relationen fuer <= und >= akzeptiert. ? und ! sind im classic-Modus absichtlich nicht erlaubt. Der Sprachkern bleibt bewusst klein: Integer, keine Parameter, keine Rueckgabewerte. Referenzen /Users/thorstenhindermann/Codex/TinyPl0/PL0.md /Users/thorstenhindermann/Codex/TinyPl0/Pflichtenheft_PL0_CSharp_DotNet10.md"
  },
  "docfx/curated/quality.html": {
    "href": "docfx/curated/quality.html",
    "title": "Qualitaet (kuratiert) | TinyPl0 Dokumentation",
    "summary": "Qualitaet (kuratiert) Dieses Kapitel fasst die Qualitaetsziele zusammen und bindet die Detailseite ein. Originalinhalt Qualität und Testabdeckung Ziel Abdeckung der Kernpfade aus Lexer, Parser/Codegenerator, VM und CLI. Testebenen Unit: Parser-/Lexer-/CLI-Optionen und VM-Operationen. Golden: Referenzvergleich von Token- und P-Code-Streams. End-to-End: source -> pcode -> vm. Kernpfad-Matrix Bereich Tests CLI-Switches und Subcommands CliOptionsParserTests Lexer + Positionstracking LexerTests, LexerGoldenTests Parser + Codegen + Dialektregeln ParserGoldenTests, ParserDiagnosticsTests VM-Laufzeit + Fehlerfälle VirtualMachineTests P-Code Datei-Roundtrip und E2E PCodeSerializerTests Katalogpflichtfaelle 8.2 + Golden-Code CatalogCasesTests Traceability Coverage-Gate (4.1.1 + 4.3) TraceabilityMatrixTests Traceability-Matrix Dokumentation: /Users/thorstenhindermann/Codex/TinyPl0/docs/TRACEABILITY_MATRIX.md Datenbasis: /Users/thorstenhindermann/Codex/TinyPl0/tests/data/expected/traceability/matrix.json Lokale Qualitätskommandos dotnet restore dotnet build TinyPl0.sln --configuration Release dotnet test TinyPl0.sln --configuration Release --no-build dotnet test TinyPl0.sln --configuration Release --collect:\"XPlat Code Coverage\" CI Der Workflow führt Build, Tests und Coverage-Collection aus. Manuelles Golden-Update Script für Maintainer-Workflow: /Users/thorstenhindermann/Codex/TinyPl0/scripts/update-golden-code.sh"
  },
  "docfx/curated/traceability-matrix.html": {
    "href": "docfx/curated/traceability-matrix.html",
    "title": "Traceability-Matrix (kuratiert) | TinyPl0 Dokumentation",
    "summary": "Traceability-Matrix (kuratiert) Die Traceability-Matrix verbindet Anforderungen und Tests. Originalinhalt TinyPl0 Traceability-Matrix Diese Matrix bildet die Coverage-Gate-Anforderung aus dem Pflichtenheft ab: jede Sprachregel aus Abschnitt 4.1.1 jede VM-Regel aus Abschnitt 4.3 muss mindestens einem Pflichttestfall zugeordnet sein. Quelle der Zuordnung Maschinenlesbare Matrix: /Users/thorstenhindermann/Codex/TinyPl0/tests/data/expected/traceability/matrix.json Referenzkatalog der Pflichttestfaelle: /Users/thorstenhindermann/Codex/TinyPl0/tests/data/expected/catalog/cases.json Automatischer Gate-Test /Users/thorstenhindermann/Codex/TinyPl0/tests/Pl0.Tests/TraceabilityMatrixTests.cs Der Test validiert: Vollstaendigkeit aller geforderten Sprachregeln. Vollstaendigkeit aller geforderten VM-Regeln. Jede Regel verweist auf mindestens einen katalogisierten Pflichttestfall."
  },
  "docfx/curated/vm-instruction-set.html": {
    "href": "docfx/curated/vm-instruction-set.html",
    "title": "VM-Instruction-Set (kuratiert) | TinyPl0 Dokumentation",
    "summary": "VM-Instruction-Set (kuratiert) Dieses Kapitel bindet das Instruktionsset der VM ein und ergaenzt es um Hinweise zur Nutzung im Unterricht. Hinweise Die P-Code-Instruktionen sind zentral fuer das P-Code-Handbuch. Beispiele in diesem Handbuch referenzieren diese Liste. Originalinhalt TinyPl0 VM-Befehlssatz Instruktionsformat Jede Instruktion besteht aus: op: Opcode l: Lexikalische Level-Differenz a: Argument (Adresse oder Untercode) Kodiert in C# als: /Users/thorstenhindermann/Codex/TinyPl0/src/Pl0.Core/Instruction.cs /Users/thorstenhindermann/Codex/TinyPl0/src/Pl0.Core/Opcode.cs Opcodes Opcode Wert Bedeutung lit 0 Konstante a auf Stack laden opr 1 ALU-/Kontrolloperation nach Untercode a lod 2 Variable aus statischer Tiefe l, Offset a laden sto 3 Obersten Stackwert in statische Tiefe l, Offset a speichern cal 4 Prozeduraufruf mit statischem Link int 5 Stack um a Zellen erweitern jmp 6 Unbedingter Sprung zu a jpc 7 Bedingter Sprung zu a bei 0 auf Stack OPR-Untercodes Untercode Bedeutung 0 Return (Frame verlassen) 1 Vorzeichenwechsel (-x) 2 Addition 3 Subtraktion 4 Multiplikation 5 Division 6 odd-Test 8 Gleichheit (=) 9 Ungleichheit (#) 10 Kleiner (<) 11 Groesser-gleich (>=) 12 Groesser (>) 13 Kleiner-gleich (<=) 14 Integer-Eingabe (?) 15 Integer-Ausgabe (!) Implementierung: /Users/thorstenhindermann/Codex/TinyPl0/src/Pl0.Vm/VirtualMachine.cs Registermodell P: Program Counter B: Basiszeiger (aktueller Aktivierungsrahmen) T: Stack-Top Statische Kette (base(l)) wird ueber ResolveBase aufgeloest. Definierte Laufzeitdiagnosen Code Bedeutung 206 Division durch 0 98 EOF bei Integer-Eingabe 97 Ungueltiges Integer-Format bei Eingabe 99 Sonstiger VM-Laufzeitfehler (z. B. Stack-/Pointerfehler)"
  },
  "docfx/handbook/pcode/advanced-examples.html": {
    "href": "docfx/handbook/pcode/advanced-examples.html",
    "title": "Ausfuehrliche Beispiele | TinyPl0 Dokumentation",
    "summary": "Ausfuehrliche Beispiele In diesem Kapitel folgen groessere P-Code-Programme mit kurzen Erklaerungen. Beispiel 1: Summe von 1 bis N Berechnet die Summe 1..N und gibt das Ergebnis aus. Lokale Variablen: n (0), i (1), sum (2). INT 0 3 OPR 0 14 // read n STO 0 0 LIT 0 1 STO 0 1 LIT 0 0 STO 0 2 LOD 0 1 LOD 0 0 OPR 0 10 // i < n JPC 0 18 LOD 0 2 LOD 0 1 OPR 0 2 // sum + i STO 0 2 LOD 0 1 LIT 0 1 OPR 0 2 // i + 1 STO 0 1 JMP 0 7 LOD 0 2 OPR 0 15 // print sum OPR 0 0 // return Beispiel 2: Maximum von zwei Zahlen INT 0 3 OPR 0 14 STO 0 0 OPR 0 14 STO 0 1 LOD 0 0 LOD 0 1 OPR 0 12 // a > b JPC 0 12 LOD 0 0 STO 0 2 JMP 0 14 LOD 0 1 STO 0 2 LOD 0 2 OPR 0 15 OPR 0 0"
  },
  "docfx/handbook/pcode/debugging.html": {
    "href": "docfx/handbook/pcode/debugging.html",
    "title": "Debugging-Tipps | TinyPl0 Dokumentation",
    "summary": "Debugging-Tipps P-Code mit --list-code ausgeben. Schrittweise durch Instruktionen gehen und Stackzustand notieren. Fehlerhafte Sprungadressen pruefen."
  },
  "docfx/handbook/pcode/index.html": {
    "href": "docfx/handbook/pcode/index.html",
    "title": "P-Code-Handbuch | TinyPl0 Dokumentation",
    "summary": "P-Code-Handbuch Dieses Kapitel erklaert den P-Code der PL/0-VM und bietet Beispiele je Instruktion. Die detaillierte Instruktionsliste wird im kuratierten Kapitel aus docs/VM_INSTRUCTION_SET.md aufbereitet. Register und Speicher P: Program Counter B: Base Pointer T: Top-of-Stack I: Instruction Register Die VM arbeitet mit einem Stack und einer separaten Code-Area."
  },
  "docfx/handbook/pcode/instruction-examples.html": {
    "href": "docfx/handbook/pcode/instruction-examples.html",
    "title": "Beispiele je Instruktion | TinyPl0 Dokumentation",
    "summary": "Beispiele je Instruktion Dieses Kapitel zeigt fuer jede Instruktion ein einfaches Beispiel. Die Kommentare erklaeren jeweils die Wirkung auf Stack und Kontrollfluss. LIT LIT 0 5 // push 5 LOD LOD 0 0 // load variable at level 0, offset 0 STO LIT 0 7 STO 0 0 // store 7 into variable 0 CAL CAL 0 10 // call procedure at address 10 INT INT 0 3 // reserve 3 cells for locals (plus 3 control cells) JMP JMP 0 20 // jump to instruction 20 JPC LIT 0 0 JPC 0 12 // if top is 0, jump to 12 OPR (Auswahl) Return (OPR 0 0) OPR 0 0 // return from procedure Negation (OPR 0 1) LIT 0 4 OPR 0 1 // result: -4 Addition (OPR 0 2) LIT 0 1 LIT 0 2 OPR 0 2 // result: 3 Subtraktion (OPR 0 3) LIT 0 10 LIT 0 3 OPR 0 3 // result: 7 Multiplikation (OPR 0 4) LIT 0 6 LIT 0 7 OPR 0 4 // result: 42 Division (OPR 0 5) LIT 0 10 LIT 0 3 OPR 0 5 // result: 3 (Integer) odd (OPR 0 6) LIT 0 5 OPR 0 6 // result: 1 Vergleich (OPR 0 8..13) LIT 0 2 LIT 0 2 OPR 0 8 // result: 1 (gleich) Read (OPR 0 14) OPR 0 14 // read int from input, push on stack Write (OPR 0 15) LIT 0 9 OPR 0 15 // write 9 to output Ausfuehrliches Mini-Programm (Summe) INT 0 3 // locals: x, y, sum LIT 0 2 STO 0 0 LIT 0 3 STO 0 1 LOD 0 0 LOD 0 1 OPR 0 2 // x + y STO 0 2 LOD 0 2 OPR 0 15 // print sum"
  },
  "docfx/handbook/pcode/instruction-reference.html": {
    "href": "docfx/handbook/pcode/instruction-reference.html",
    "title": "Instruktions-Referenz | TinyPl0 Dokumentation",
    "summary": "Instruktions-Referenz Dieses Kapitel beschreibt alle P-Code-Elemente, die die VM versteht. Grundform OPCODE LEVEL ARG OPCODE: Mnemonic (z. B. LIT, LOD) LEVEL: Lexikalische Ebene (statisch verschachtelte Prozeduren) ARG: Argument oder Adresse Instruktionen LIT Laedt eine Konstante auf den Stack. LOD Laedt eine Variable von einer (LEVEL, ARG)-Adresse auf den Stack. STO Speichert den Wert vom Stack in eine Variable an (LEVEL, ARG). CAL Ruft eine Prozedur an der Zieladresse auf und legt einen neuen Stack-Frame an. INT Reserviert Speicher auf dem Stack fuer lokale Variablen. JMP Unbedingter Sprung zur Zieladresse. JPC Bedingter Sprung zur Zieladresse, wenn der Stack-Top 0 (false) ist. OPR Fuehrt Operationen aus. Die Bedeutung von ARG ist: 0: Return (Rueckkehr aus Prozedur) 1: Negation 2: Addition 3: Subtraktion 4: Multiplikation 5: Division (Integer) 6: odd-Test 8: Gleichheit 9: Ungleichheit 10: Kleiner 11: Groesser gleich 12: Groesser 13: Kleiner gleich 14: Read (Eingabe) 15: Write (Ausgabe) Die vollstaendige Referenz wird zusaetzlich aus dem VM-Instruction-Set kuratiert eingebunden."
  },
  "docfx/handbook/pl0/best-practices.html": {
    "href": "docfx/handbook/pl0/best-practices.html",
    "title": "Best Practices | TinyPl0 Dokumentation",
    "summary": "Best Practices Kleine, klar strukturierte Prozeduren. Aussagekraeftige Bezeichner fuer Variablen und Konstanten. Einfache, gut lesbare Bedingungen in if und while. P-Code-Listen fuer Lernzwecke aktivieren."
  },
  "docfx/handbook/pl0/common-errors.html": {
    "href": "docfx/handbook/pl0/common-errors.html",
    "title": "Typische Fehler | TinyPl0 Dokumentation",
    "summary": "Typische Fehler Fehlendes abschliessendes . am Programmende. Zuweisung an eine Konstante. Verwendung nicht deklarierter Bezeichner. Vergessene end-Markierung in Bloecken."
  },
  "docfx/handbook/pl0/elements/conditions.html": {
    "href": "docfx/handbook/pl0/elements/conditions.html",
    "title": "Bedingungen | TinyPl0 Dokumentation",
    "summary": "Bedingungen Bedingungen steuern den Programmfluss mit if ... then und Vergleichsoperatoren. Regeln Jede Bedingung liefert 0 (false) oder 1 (true) in der VM. Vergleichsoperatoren: =, #, <, <=, >, >= Kurz var x; begin x := 1; if x = 1 then ! x end. Mittel var x; begin x := 5; if x > 3 then ! x end. Ausfuehrlich var a, b; begin a := 4; b := 7; if a < b then ! b end. Erklaerung Bedingungen pruefen Relationen und steuern den Kontrollfluss. In PL/0 gibt es kein else; alternative Zweige werden mit weiteren if gebaut. Siehe auch Anhang: Primzahltest Anhang: Zahlenvergleich"
  },
  "docfx/handbook/pl0/elements/constants.html": {
    "href": "docfx/handbook/pl0/elements/constants.html",
    "title": "Konstanten | TinyPl0 Dokumentation",
    "summary": "Konstanten Konstanten werden mit const deklariert und koennen im weiteren Programmverlauf nicht geaendert werden. Regeln Konstanten muessen vor Variablen deklariert werden. Zuweisungen an Konstanten sind nicht erlaubt. Kurz const pi = 3; var r; begin r := pi; ! r end. Mittel const limit = 10, step = 2; var x; begin x := 0; while x < limit do begin ! x; x := x + step end end. Ausfuehrlich const base = 2, max = 16; var value; procedure show; begin ! value end; begin value := base; while value <= max do begin call show; value := value * base end end. Erklaerung Im kurzen Beispiel wird eine Konstante direkt verwendet. Im mittleren Beispiel zeigt step, wie feste Schrittweiten genutzt werden. Im ausfuehrlichen Beispiel demonstriert base die wiederholte Multiplikation. Siehe auch Anhang: Math Functions Anhang: Kreis"
  },
  "docfx/handbook/pl0/elements/io.html": {
    "href": "docfx/handbook/pl0/elements/io.html",
    "title": "Ein- und Ausgabe | TinyPl0 Dokumentation",
    "summary": "Ein- und Ausgabe Im erweiterten Dialekt stehen ? ident (Eingabe) und ! expression (Ausgabe) zur Verfuegung. Regeln Ein-/Ausgabe ist nur im Dialekt extended erlaubt. ? liest einen Integer, ! gibt einen Integer aus. Kurz var x; begin ? x; ! x end. Mittel var x; begin ? x; x := x + 1; ! x end. Ausfuehrlich var x, y; var max; begin ? x; ? y; if x > y then max := x; if y >= x then max := y; ! max end. Erklaerung ? liest genau einen Integer von der Eingabe. ! gibt einen Integer aus. Im ausfuehrlichen Beispiel wird das Maximum zweier Eingaben ausgegeben. Siehe auch Anhang: Min Max Anhang: Statistik"
  },
  "docfx/handbook/pl0/elements/loops.html": {
    "href": "docfx/handbook/pl0/elements/loops.html",
    "title": "Schleifen | TinyPl0 Dokumentation",
    "summary": "Schleifen Schleifen werden mit while ... do gebildet. Regeln Die Bedingung wird vor jeder Iteration geprueft. Der Schleifenkoerper kann ein einzelnes Statement oder ein begin ... end Block sein. Kurz var x; begin x := 0; while x < 3 do x := x + 1; ! x end. Mittel var x; begin x := 1; while x <= 4 do begin ! x; x := x + 1 end end. Ausfuehrlich var x, sum; begin x := 1; sum := 0; while x <= 5 do begin sum := sum + x; x := x + 1 end; ! sum end. Erklaerung Die Schleife bricht ab, sobald die Bedingung false ist. Im ausfuehrlichen Beispiel wird eine laufende Summe gebildet. Siehe auch Anhang: Countdown Anhang: Fibonacci"
  },
  "docfx/handbook/pl0/elements/procedures.html": {
    "href": "docfx/handbook/pl0/elements/procedures.html",
    "title": "Prozeduren | TinyPl0 Dokumentation",
    "summary": "Prozeduren Prozeduren kapseln wiederverwendbare Ablaufe. PL/0 kennt keine Parameter, aber Prozeduren koennen auf Variablen in aeusseren Bloecken zugreifen. Regeln Prozeduren werden mit procedure <name>; eingefuehrt. Parameter und Rueckgabewerte gibt es nicht. Kurz var x; procedure show; begin ! x end; begin x := 1; call show end. Mittel var x; procedure inc; begin x := x + 1 end; begin x := 0; call inc; call inc; ! x end. Ausfuehrlich var x; procedure loop; var i; begin i := 0; while i < 3 do begin x := x + 1; i := i + 1 end end; begin x := 5; call loop; ! x end. Erklaerung Prozeduren haben keinen Parameter, greifen aber auf aeussere Variablen zu. Das mittlere Beispiel erhoeht einen Wert mehrfach. Das ausfuehrliche Beispiel zeigt einen lokalen Zaehler innerhalb der Prozedur. Siehe auch Anhang: Kgt Anhang: Ggt"
  },
  "docfx/handbook/pl0/elements/variables.html": {
    "href": "docfx/handbook/pl0/elements/variables.html",
    "title": "Variablen | TinyPl0 Dokumentation",
    "summary": "Variablen Variablen werden mit var deklariert und koennen spaeter per := zugewiesen werden. Regeln Variablen muessen vor ihrer Verwendung deklariert werden. Werte sind immer Integer. Kurz var x; begin x := 1; ! x end. Mittel var x, y; begin x := 3; y := x * 2; ! y end. Ausfuehrlich var a, b, c; begin a := 5; b := 7; c := a * b + 3; ! a; ! b; ! c end. Erklaerung Variablen muessen vor der ersten Zuweisung deklariert sein. Die Beispiele zeigen einfache Berechnungen und Ausgabe. Im ausfuehrlichen Beispiel werden mehrere Variablen kombiniert. Siehe auch Anhang: Summe 1 Bis N Anhang: Mittelwert"
  },
  "docfx/handbook/pl0/index.html": {
    "href": "docfx/handbook/pl0/index.html",
    "title": "PL0-Handbuch | TinyPl0 Dokumentation",
    "summary": "PL0-Handbuch Dieses Handbuch erklaert die Sprache PL/0 und bietet pro Sprachelement Beispiele in drei Lernstufen: kurz, mittel und ausfuehrlich. Hinweis: TinyPl0 unterstuetzt die Dialekte classic und extended. Der extended Dialekt umfasst ? (Eingabe) und ! (Ausgabe). Inhalte Sprachelemente (Konstanten, Variablen, Prozeduren, Bedingungen, Schleifen, Ein-/Ausgabe) Syntax-Referenz Best Practices und typische Fehler"
  },
  "docfx/handbook/pl0/syntax.html": {
    "href": "docfx/handbook/pl0/syntax.html",
    "title": "Syntax-Referenz | TinyPl0 Dokumentation",
    "summary": "Syntax-Referenz Die offizielle EBNF fuer PL/0 befindet sich im kuratierten Kapitel aus docs/LANGUAGE_EBNF.md. Hier wird eine kurze Uebersicht der wichtigsten Konstrukte gegeben. const: Konstantenblock var: Variablenblock procedure: Prozedurdefinition begin ... end: Block if ... then: Bedingung while ... do: Schleife ? ident: Eingabe (extended) ! expression: Ausgabe (extended)"
  },
  "docfx/handbook/tutorial/exercises.html": {
    "href": "docfx/handbook/tutorial/exercises.html",
    "title": "Schritt-fuer-Schritt Uebungen | TinyPl0 Dokumentation",
    "summary": "Schritt-fuer-Schritt Uebungen Uebung 1: Addition LIT 0 2 LIT 0 3 OPR 0 2 Aufgabe: Fuege eine Speicherung in eine Variable hinzu (STO 0 0). Gib das Ergebnis mit OPR 0 15 aus. Uebung 2: Bedingter Sprung LIT 0 0 JPC 0 5 LIT 0 1 Aufgabe: Ergaenze den Code, sodass bei falscher Bedingung ein anderer Wert geladen wird. Stelle sicher, dass beide Zweige am Ende das Ergebnis ausgeben. Uebung 3: Schleife zaehlen INT 0 1 LIT 0 0 STO 0 0 LOD 0 0 LIT 0 5 OPR 0 10 JPC 0 12 LOD 0 0 OPR 0 15 LOD 0 0 LIT 0 1 OPR 0 2 STO 0 0 JMP 0 3 OPR 0 0 Aufgabe: Beschrifte jede Zeile mit einem Kommentar. Variiere die obere Grenze der Schleife."
  },
  "docfx/handbook/tutorial/index.html": {
    "href": "docfx/handbook/tutorial/index.html",
    "title": "Tutorial: Direkte P-Code-Programmierung | TinyPl0 Dokumentation",
    "summary": "Tutorial: Direkte P-Code-Programmierung Dieses Tutorial fuehrt Auszubildende in die direkte P-Code-Programmierung ein. Es baut schrittweise von einfachen Instruktionen bis zu kleinen Programmen auf. Voraussetzung: Grundkenntnisse zu Stack und einfachen Kontrollstrukturen."
  },
  "docfx/handbook/tutorial/learning-path.html": {
    "href": "docfx/handbook/tutorial/learning-path.html",
    "title": "Lernpfad | TinyPl0 Dokumentation",
    "summary": "Lernpfad Register und Stack verstehen. P (Program Counter), B (Base), T (Top), I (Instruction). Grundinstruktionen (LIT, LOD, STO). Werte laden, speichern, Stack bewegen. Arithmetik mit OPR. Addieren, subtrahieren, vergleichen. Spruenge und Schleifen (JMP, JPC). Bedingungen in P-Code abbilden. Prozeduraufrufe (CAL). Stack-Frames und Rueckkehr verstehen."
  },
  "docfx/handbook/tutorial/mini-projects.html": {
    "href": "docfx/handbook/tutorial/mini-projects.html",
    "title": "Mini-Projekte | TinyPl0 Dokumentation",
    "summary": "Mini-Projekte Zaehler mit Schleife und Ausgabe. Nutze INT, LIT, STO, JPC, JMP und OPR 15. Vergleich zweier Werte mit bedingtem Sprung. Baue eine Max-Funktion mit OPR 12 und zwei Sprungzielen. Kleines Programm mit Prozeduraufruf. Eine Prozedur erhoeht einen Wert, Hauptprogramm ruft sie mehrfach auf."
  },
  "docfx/projects/overview.html": {
    "href": "docfx/projects/overview.html",
    "title": "Architektur und Projektuebersicht | TinyPl0 Dokumentation",
    "summary": "Architektur und Projektuebersicht TinyPl0 ist in drei Projekte gegliedert: Pl0.CLI: Kommandozeilenwerkzeug fuer Kompilierung und Ausfuehrung. Pl0.Core: Lexer, Parser, Compiler und P-Code-Serialisierung. Pl0.Vm: P-Code-Interpreter inkl. I/O-Adapter. Die detaillierte Architektur sowie weitere Referenzen werden im Kapitel \"Inhalte aus docs/\" kuratiert aufgearbeitet."
  },
  "docfx/projects/pl0-cli.html": {
    "href": "docfx/projects/pl0-cli.html",
    "title": "Pl0.CLI | TinyPl0 Dokumentation",
    "summary": "Pl0.CLI Zweck Die CLI stellt die Befehle compile, run und run-pcode bereit und verbindet Compiler und VM. Wichtige Bestandteile Optionen-Parser fuer Pascal-kompatible Compiler-Switches. Ausgabe von P-Code-Listen fuer didaktische Zwecke. Diagnoseausgaben fuer Fehler und Warnungen. Einstieg dotnet run --project src/Pl0.Cli -- compile <datei.pl0> --out /tmp/example.pcode"
  },
  "docfx/projects/pl0-core.html": {
    "href": "docfx/projects/pl0-core.html",
    "title": "Pl0.Core | TinyPl0 Dokumentation",
    "summary": "Pl0.Core Zweck Pl0.Core enthaelt den Lexer, Parser und Compiler fuer PL/0 sowie die P-Code-Serialisierung. Verantwortlichkeiten Tokenisierung (Lexer) mit Positionsdaten. Syntaxanalyse (Parser) inkl. Symboltabelle. Codegenerierung (P-Code). Diagnoseobjekte fuer Fehler und Warnungen."
  },
  "docfx/projects/pl0-vm.html": {
    "href": "docfx/projects/pl0-vm.html",
    "title": "Pl0.Vm | TinyPl0 Dokumentation",
    "summary": "Pl0.Vm Zweck Pl0.Vm stellt die virtuelle Maschine fuer P-Code sowie I/O-Adapter bereit. Verantwortlichkeiten Interpreter fuer die P-Code-Instruktionen. Abstraktionen fuer Ein-/Ausgabe (Console/Buffered). Laufzeit-Diagnosen und Ergebnisobjekte."
  },
  "docfx/start/installation.html": {
    "href": "docfx/start/installation.html",
    "title": "Installation und Nutzung | TinyPl0 Dokumentation",
    "summary": "Installation und Nutzung Installation .NET SDK 10 installieren. Repository klonen. dotnet build ausfuehren. Nutzung CLI: dotnet run --project src/Pl0.Cli -- <command> <datei.pl0> Unterstuetzte Commands: compile, run, run-pcode Beispiel dotnet run --project src/Pl0.Cli -- run tests/data/pl0/valid/feature_const_var_assignment.pl0"
  },
  "docfx/start/license.html": {
    "href": "docfx/start/license.html",
    "title": "Lizenz | TinyPl0 Dokumentation",
    "summary": "Lizenz Dieses Projekt steht unter der MIT-Lizenz. Details stehen in der Datei LICENSE im Repository."
  },
  "docfx/start/overview.html": {
    "href": "docfx/start/overview.html",
    "title": "Überblick | TinyPl0 Dokumentation",
    "summary": "Überblick TinyPl0 ist eine C#-Portierung des historischen PL/0-Compilers inklusive Virtual Machine (P-Code). Das Projekt dient als Ausbildungs- und Lehrbeispiel und legt besonderen Wert auf Nachvollziehbarkeit und vollständige Dokumentation. Zielgruppe Auszubildende und Studierende, die Compiler- und VM-Grundlagen lernen. Lehrende, die Beispiele für PL/0 und P-Code benötigen. Entwickler, die sich mit der Portierung von Pascal nach C# befassen. Struktur der Dokumentation Einstieg und Nutzung der CLI. Architektur und Projektaufteilung. PL0-Handbuch mit Lernstufen. P-Code-Handbuch und P-Code-Tutorial. API-Referenz. Anhang mit Beispielprogrammen."
  },
  "docfx/start/quickstart.html": {
    "href": "docfx/start/quickstart.html",
    "title": "Schnellstart | TinyPl0 Dokumentation",
    "summary": "Schnellstart Voraussetzungen .NET SDK 10 Build und Tests dotnet build dotnet test CLI-Beispiele # PL/0 Quelltext ausfuehren dotnet run --project src/Pl0.Cli -- run tests/data/pl0/valid/feature_io_q_bang_relops.pl0 # Kompilieren nach .pcode dotnet run --project src/Pl0.Cli -- compile tests/data/pl0/valid/feature_const_var_assignment.pl0 --out /tmp/example.pcode"
  },
  "docfx/start/support.html": {
    "href": "docfx/start/support.html",
    "title": "Support und Feedback | TinyPl0 Dokumentation",
    "summary": "Support und Feedback Bitte fuer Support und Feedback ein Issue in diesem GitHub-Repository erstellen."
  },
  "docfx/usage/cli.html": {
    "href": "docfx/usage/cli.html",
    "title": "Nutzung der CLI | TinyPl0 Dokumentation",
    "summary": "Nutzung der CLI Commands compile: PL/0 nach P-Code kompilieren. run: PL/0 direkt ausfuehren. run-pcode: P-Code-Datei ausfuehren. Typische Optionen --out: Zielpfad fuer P-Code. --list-code: P-Code-Liste ausgeben. --emit: Emissionsmodus fuer Diagnosen. Beispiele dotnet run --project src/Pl0.Cli -- run tests/data/pl0/valid/feature_io_q_bang_relops.pl0"
  },
  "docfx/usage/configuration.html": {
    "href": "docfx/usage/configuration.html",
    "title": "Konfiguration | TinyPl0 Dokumentation",
    "summary": "Konfiguration Die CLI bietet Optionen, die das Verhalten des Compilers und der VM beeinflussen. Details werden im API-Teil der CLI-Optionen dokumentiert."
  },
  "docfx/usage/examples.html": {
    "href": "docfx/usage/examples.html",
    "title": "Beispiele | TinyPl0 Dokumentation",
    "summary": "Beispiele Kurz const a = 1; var x; begin x := a; ! x end. Mittel const limit = 5; var x; begin x := 0; while x < limit do begin ! x; x := x + 1 end end. Ausfuehrlich const limit = 10; var x; procedure show; begin ! x end; begin x := 0; while x < limit do begin call show; x := x + 1 end end."
  },
  "docs/ARCHITECTURE.html": {
    "href": "docs/ARCHITECTURE.html",
    "title": "TinyPl0 Architektur | TinyPl0 Dokumentation",
    "summary": "TinyPl0 Architektur Überblick TinyPl0 ist in drei Laufzeitmodule getrennt: flowchart LR A[\"PL/0 Source (.pl0)\"] --> B[\"Pl0.Core\\nLexer + Parser + SymbolTable + CodeGen\"] B --> C[\"P-Code Instructions\"] C --> D[\"Pl0.Vm\\nVirtualMachine\"] D --> E[\"Program Output / Stack State\"] F[\"Pl0.Cli\"] --> B F --> D F --> G[\".pcode Files\"] G --> D Module Pl0.Core: Sprachverarbeitung und Codegenerierung. Pl0.Vm: Stackbasierte P-Code-Ausführung inklusive I/O-Adapter. Pl0.Cli: Bedienoberfläche (compile, run, run-pcode) und Dateifluss. Datenfluss .pl0 wird im Core lexikalisch analysiert. Parser erzeugt aus Tokens P-Code-Instruktionen. CLI kann P-Code als .pcode speichern oder direkt ausführen. VM interpretiert Instruktionen deterministisch auf einem Integer-Stack. Pascal -> C# Mapping (Kompakt) Pascal-Referenz C#-Implementierung getsym/getch Pl0Lexer block/statement/condition/expression Pl0Parser enter/position/table SymbolTable + SymbolEntry gen Pl0Parser.Emit interpret VirtualMachine.Run base(l) VirtualMachine.ResolveBase PrintUsage CliHelpPrinter Dialekte Classic: ohne ?/!, nahe am Pascal-Vorbild. Extended: mit ? ident und ! expression."
  },
  "docs/LANGUAGE_EBNF.html": {
    "href": "docs/LANGUAGE_EBNF.html",
    "title": "TinyPl0 Sprachumfang und EBNF | TinyPl0 Dokumentation",
    "summary": "TinyPl0 Sprachumfang und EBNF Dialekte classic: orientiert am historischen PL/0 ohne ? und !. extended: enthält zusätzlich Eingabe ? ident und Ausgabe ! expression. Konsolidierte EBNF program = block \".\" ; block = [ \"const\" ident \"=\" number { \",\" ident \"=\" number } \";\" ] [ \"var\" ident { \",\" ident } \";\" ] { \"procedure\" ident \";\" block \";\" } statement ; statement = [ ident \":=\" expression | \"call\" ident | \"?\" ident | \"!\" expression | \"begin\" statement { \";\" statement } \"end\" | \"if\" condition \"then\" statement | \"while\" condition \"do\" statement ] ; condition = \"odd\" expression | expression relop expression ; relop = \"=\" | \"#\" | \"<\" | \"<=\" | \">\" | \">=\" | \"[\" | \"]\" ; expression = [ \"+\" | \"-\" ] term { ( \"+\" | \"-\" ) term } ; term = factor { ( \"*\" | \"/\" ) factor } ; factor = ident | number | \"(\" expression \")\" ; Hinweise zur Kompatibilität [ und ] werden als historische Relationen fuer <= und >= akzeptiert. ? und ! sind im classic-Modus absichtlich nicht erlaubt. Der Sprachkern bleibt bewusst klein: Integer, keine Parameter, keine Rueckgabewerte. Referenzen /Users/thorstenhindermann/Codex/TinyPl0/PL0.md /Users/thorstenhindermann/Codex/TinyPl0/Pflichtenheft_PL0_CSharp_DotNet10.md"
  },
  "docs/QUALITY.html": {
    "href": "docs/QUALITY.html",
    "title": "Qualität und Testabdeckung | TinyPl0 Dokumentation",
    "summary": "Qualität und Testabdeckung Ziel Abdeckung der Kernpfade aus Lexer, Parser/Codegenerator, VM und CLI. Testebenen Unit: Parser-/Lexer-/CLI-Optionen und VM-Operationen. Golden: Referenzvergleich von Token- und P-Code-Streams. End-to-End: source -> pcode -> vm. Kernpfad-Matrix Bereich Tests CLI-Switches und Subcommands CliOptionsParserTests Lexer + Positionstracking LexerTests, LexerGoldenTests Parser + Codegen + Dialektregeln ParserGoldenTests, ParserDiagnosticsTests VM-Laufzeit + Fehlerfälle VirtualMachineTests P-Code Datei-Roundtrip und E2E PCodeSerializerTests Katalogpflichtfaelle 8.2 + Golden-Code CatalogCasesTests Traceability Coverage-Gate (4.1.1 + 4.3) TraceabilityMatrixTests Traceability-Matrix Dokumentation: /Users/thorstenhindermann/Codex/TinyPl0/docs/TRACEABILITY_MATRIX.md Datenbasis: /Users/thorstenhindermann/Codex/TinyPl0/tests/data/expected/traceability/matrix.json Lokale Qualitätskommandos dotnet restore dotnet build TinyPl0.sln --configuration Release dotnet test TinyPl0.sln --configuration Release --no-build dotnet test TinyPl0.sln --configuration Release --collect:\"XPlat Code Coverage\" CI Der Workflow führt Build, Tests und Coverage-Collection aus. Manuelles Golden-Update Script für Maintainer-Workflow: /Users/thorstenhindermann/Codex/TinyPl0/scripts/update-golden-code.sh"
  },
  "docs/TRACEABILITY_MATRIX.html": {
    "href": "docs/TRACEABILITY_MATRIX.html",
    "title": "TinyPl0 Traceability-Matrix | TinyPl0 Dokumentation",
    "summary": "TinyPl0 Traceability-Matrix Diese Matrix bildet die Coverage-Gate-Anforderung aus dem Pflichtenheft ab: jede Sprachregel aus Abschnitt 4.1.1 jede VM-Regel aus Abschnitt 4.3 muss mindestens einem Pflichttestfall zugeordnet sein. Quelle der Zuordnung Maschinenlesbare Matrix: /Users/thorstenhindermann/Codex/TinyPl0/tests/data/expected/traceability/matrix.json Referenzkatalog der Pflichttestfaelle: /Users/thorstenhindermann/Codex/TinyPl0/tests/data/expected/catalog/cases.json Automatischer Gate-Test /Users/thorstenhindermann/Codex/TinyPl0/tests/Pl0.Tests/TraceabilityMatrixTests.cs Der Test validiert: Vollstaendigkeit aller geforderten Sprachregeln. Vollstaendigkeit aller geforderten VM-Regeln. Jede Regel verweist auf mindestens einen katalogisierten Pflichttestfall."
  },
  "docs/VM_INSTRUCTION_SET.html": {
    "href": "docs/VM_INSTRUCTION_SET.html",
    "title": "TinyPl0 VM-Befehlssatz | TinyPl0 Dokumentation",
    "summary": "TinyPl0 VM-Befehlssatz Instruktionsformat Jede Instruktion besteht aus: op: Opcode l: Lexikalische Level-Differenz a: Argument (Adresse oder Untercode) Kodiert in C# als: /Users/thorstenhindermann/Codex/TinyPl0/src/Pl0.Core/Instruction.cs /Users/thorstenhindermann/Codex/TinyPl0/src/Pl0.Core/Opcode.cs Opcodes Opcode Wert Bedeutung lit 0 Konstante a auf Stack laden opr 1 ALU-/Kontrolloperation nach Untercode a lod 2 Variable aus statischer Tiefe l, Offset a laden sto 3 Obersten Stackwert in statische Tiefe l, Offset a speichern cal 4 Prozeduraufruf mit statischem Link int 5 Stack um a Zellen erweitern jmp 6 Unbedingter Sprung zu a jpc 7 Bedingter Sprung zu a bei 0 auf Stack OPR-Untercodes Untercode Bedeutung 0 Return (Frame verlassen) 1 Vorzeichenwechsel (-x) 2 Addition 3 Subtraktion 4 Multiplikation 5 Division 6 odd-Test 8 Gleichheit (=) 9 Ungleichheit (#) 10 Kleiner (<) 11 Groesser-gleich (>=) 12 Groesser (>) 13 Kleiner-gleich (<=) 14 Integer-Eingabe (?) 15 Integer-Ausgabe (!) Implementierung: /Users/thorstenhindermann/Codex/TinyPl0/src/Pl0.Vm/VirtualMachine.cs Registermodell P: Program Counter B: Basiszeiger (aktueller Aktivierungsrahmen) T: Stack-Top Statische Kette (base(l)) wird ueber ResolveBase aufgeloest. Definierte Laufzeitdiagnosen Code Bedeutung 206 Division durch 0 98 EOF bei Integer-Eingabe 97 Ungueltiges Integer-Format bei Eingabe 99 Sonstiger VM-Laufzeitfehler (z. B. Stack-/Pointerfehler)"
  },
  "index.html": {
    "href": "index.html",
    "title": "TinyPl0 – Dokumentation & Ausbildung | TinyPl0 Dokumentation",
    "summary": "TinyPl0 – Dokumentation & Ausbildung Willkommen zur zentralen Dokumentation von TinyPl0. Dieses Projekt dient als didaktische Portierung des historischen PL/0-Compilers nach C# auf .NET 10. Diese Dokumentation ist speziell für die Ausbildung in der Fachinformatik konzipiert und bietet einen tiefen Einblick in die Funktionsweise von Compilern und virtuellen Maschinen. Hauptbereiche \uD83D\uDE80 Erste Schritte Erfahren Sie, wie Sie TinyPl0 installieren und Ihren ersten PL/0-Code ausführen. Zum Schnellstart \uD83D\uDCD8 PL/0 Handbuch Lernen Sie die Syntax und die Konzepte der Sprache PL/0 kennen – von Konstanten bis zu Prozeduren. Sprachreferenz \uD83D\uDCBB P-Code & VM Tauchen Sie ab in die Welt der Zwischencodes. Verstehen Sie, wie die Stack-Maschine Instruktionen verarbeitet. P-Code Details \uD83C\uDFD7️ Architektur Analyse der drei Teilprojekte: Core, VM und CLI sowie deren Zusammenspiel. Architektur-Überblick Über das Projekt TinyPl0 ist mehr als nur ein Compiler. Es ist ein Lernwerkzeug: Einfachheit: PL/0 ist eine minimalistische Sprache, ideal zum Erlernen von Compilerbau-Grundlagen. Modernität: Implementiert in C# 14 und .NET 10. Transparenz: Vollständige Traceability von Anforderungen bis zu den Tests. Tip Besuchen Sie den Anhang, um eine Vielzahl von Beispielprogrammen (wie Fibonacci oder Kreisberechnung) zu entdecken und direkt auszuprobieren. Lizenz: MIT – siehe LICENSE. Dieses Projekt dient zu Ausbildungszwecken für Auszubildende der Fachinformatik."
  }
}